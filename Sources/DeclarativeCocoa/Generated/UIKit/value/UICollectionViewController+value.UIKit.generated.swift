
// Generated file
// DO NOT EDIT THIS FILE

#if canImport(UIKit)
import UIKit

extension Modify.DynamicMemberWrap where T: UICollectionViewController {
    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didHighlightItemAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, didHighlightItemAt: indexPath)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didUnhighlightItemAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, didUnhighlightItemAt: indexPath)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, didSelectItemAt: indexPath)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didDeselectItemAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, didDeselectItemAt: indexPath)
        return self.value
    }

    @available(iOS 16.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, performPrimaryActionForItemAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, performPrimaryActionForItemAt: indexPath)
        return self.value
    }

    @available(iOS 8.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, willDisplay: cell, forItemAt: indexPath)
        return self.value
    }

    @available(iOS 8.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplaySupplementaryView view: UIKit.UICollectionReusableView, forElementKind elementKind: Swift.String, at indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, willDisplaySupplementaryView: view, forElementKind: elementKind, at: indexPath)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplaying cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, didEndDisplaying: cell, forItemAt: indexPath)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplayingSupplementaryView view: UIKit.UICollectionReusableView, forElementOfKind elementKind: Swift.String, at indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, didEndDisplayingSupplementaryView: view, forElementOfKind: elementKind, at: indexPath)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    @available(iOS, introduced: 6.0, deprecated: 13.0)
    public func collectionView(_ collectionView: UIKit.UICollectionView, performAction action: ObjectiveC.Selector, forItemAt indexPath: Foundation.IndexPath, withSender sender: Any?) -> T {
        self.value.collectionView(collectionView, performAction: action, forItemAt: indexPath, withSender: sender)
        return self.value
    }

    @available(iOS 9.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didUpdateFocusIn context: UIKit.UICollectionViewFocusUpdateContext, with coordinator: UIKit.UIFocusAnimationCoordinator) -> T {
        self.value.collectionView(collectionView, didUpdateFocusIn: context, with: coordinator)
        return self.value
    }

    @available(iOS 13.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, didBeginMultipleSelectionInteractionAt indexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, didBeginMultipleSelectionInteractionAt: indexPath)
        return self.value
    }

    @available(iOS 13.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionViewDidEndMultipleSelectionInteraction(_ collectionView: UIKit.UICollectionView) -> T {
        self.value.collectionViewDidEndMultipleSelectionInteraction(collectionView)
        return self.value
    }

    @available(iOS 13.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, willPerformPreviewActionForMenuWith configuration: UIKit.UIContextMenuConfiguration, animator: UIKit.UIContextMenuInteractionCommitAnimating) -> T {
        self.value.collectionView(collectionView, willPerformPreviewActionForMenuWith: configuration, animator: animator)
        return self.value
    }

    @available(iOS 13.2, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplayContextMenu configuration: UIKit.UIContextMenuConfiguration, animator: UIKit.UIContextMenuInteractionAnimating?) -> T {
        self.value.collectionView(collectionView, willDisplayContextMenu: configuration, animator: animator)
        return self.value
    }

    @available(iOS 13.2, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, willEndContextMenuInteraction configuration: UIKit.UIContextMenuConfiguration, animator: UIKit.UIContextMenuInteractionAnimating?) -> T {
        self.value.collectionView(collectionView, willEndContextMenuInteraction: configuration, animator: animator)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewDidScroll(scrollView)
        return self.value
    }

    @available(iOS 3.2, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewDidZoom(scrollView)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewWillBeginDragging(scrollView)
        return self.value
    }

    @available(iOS 5.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>) -> T {
        self.value.scrollViewWillEndDragging(scrollView, withVelocity: velocity, targetContentOffset: targetContentOffset)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool) -> T {
        self.value.scrollViewDidEndDragging(scrollView, willDecelerate: decelerate)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewWillBeginDecelerating(scrollView)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewDidEndDecelerating(scrollView)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewDidEndScrollingAnimation(scrollView)
        return self.value
    }

    @available(iOS 3.2, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewWillBeginZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?) -> T {
        self.value.scrollViewWillBeginZooming(scrollView, with: view)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidEndZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?, atScale scale: CoreFoundation.CGFloat) -> T {
        self.value.scrollViewDidEndZooming(scrollView, with: view, atScale: scale)
        return self.value
    }

    @available(iOS 6.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidScrollToTop(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewDidScrollToTop(scrollView)
        return self.value
    }

    @available(iOS 11.0, *)
    @discardableResult
    @_disfavoredOverload
    public func scrollViewDidChangeAdjustedContentInset(_ scrollView: UIKit.UIScrollView) -> T {
        self.value.scrollViewDidChangeAdjustedContentInset(scrollView)
        return self.value
    }

    @available(iOS 9.0, *)
    @discardableResult
    @_disfavoredOverload
    public func collectionView(_ collectionView: UIKit.UICollectionView, moveItemAt sourceIndexPath: Foundation.IndexPath, to destinationIndexPath: Foundation.IndexPath) -> T {
        self.value.collectionView(collectionView, moveItemAt: sourceIndexPath, to: destinationIndexPath)
        return self.value
    }
}

#endif
