import glob
import os
import re
import argparse

header = '''
// Generated file
// DO NOT EDIT THIS FILE

'''

generated_dir_path = '../Sources/DeclarativeCocoa/Generated'

tab = '    '

overwrite = False
target = 'Cocoa'

def generate(file: str):
    class_name = file.split('/')[-1]

    output_path = f"{generated_dir_path}/{target}/wrap/{class_name}+.generated.swift"

    f = open(file, 'r', encoding='UTF-8')
    text = f.read()

    # Strip Comments
    text = re.sub('/\*(.|\s)*?\*/', '', text)
    text = re.sub('//.*', '', text)

    lines = text.split(sep="\n")
    lines = list(filter(lambda line: line.startswith(tab), lines))
    lines = list(map(lambda line: line[len(tab):], lines))
    lines = list(filter(lambda line: not line.startswith(tab), lines))

    output_lines = list[str]()

    current_attributes = list[str]()
    for line in lines:
        if line.startswith('@') and (not 'var ' in line) and (not 'func ' in line):
            current_attributes.append(line)
        else:
            function = f"{tab}@discardableResult\n{tab}{line}"
            if len(current_attributes) == 0:
                output_lines.append(function)
            else:
                output_lines.append(tab + f'\n{tab}'.join(current_attributes) + '\n' + function)
            current_attributes = []

    output_lines = list(filter(lambda line: not 'var ' in line, output_lines))
    output_lines = list(filter(lambda line: not 'class func' in line, output_lines))
    output_lines = list(filter(lambda line: not ' init' in line, output_lines))
    output_lines = list(filter(lambda line: not ' optional ' in line, output_lines))
    output_lines = list(filter(lambda line: not '@IBAction ' in line, output_lines))
    output_lines = list(filter(lambda line: line.endswith(')'), output_lines))
    output_lines = list(map(lambda line: line.replace('open ', 'public '), output_lines))

    def convert(line: str) -> str:
        components = line.split('\n')[-1].split(' ')
        function_name = components[components.index('func') + 1]

        inputs = list(filter(lambda c: len(c) > 0 and c[-1] == ':', components))
        inputs = list(map(lambda c: c[:-1], inputs))
        inputs = list(map(lambda c: c.split('(')[-1], inputs))
        inputs = list(filter(lambda c: not len(c) == 0, inputs))

        if not  function_name[-2:] == '()':
            function_name = function_name.split('(')[0] + '(' + ', '.join(inputs) + ')'

        return line + ' -> Self' + ' {\n' + f'{tab}{tab}value.' + function_name + f"\n{tab}{tab}return self\n{tab}}}"

    output_lines = list(map(convert, output_lines))

    output = header
    output += f'#if canImport({target})\nimport {target}\n\nextension Modify.DynamicMemberWrap where T: ' + class_name + ' {\n'
    output += '\n\n'.join(output_lines)
    output += '\n}\n\n#endif\n'

    f.close()

    if overwrite or not os.path.exists(output_path):
        f = open(output_path, 'w')
        f.write(output)
        f.close()


def parse_args():
    global overwrite, target

    parser = argparse.ArgumentParser(
        description="generate modifier"
    )

    parser.add_argument("--target",
                        type=str,
                        help="target(Cocoa/UIKit)",
                        default=target,
                        required=True)
    parser.add_argument("--overwrite",
                        action='store_true',
                        help="overwrite generated files",
                        default=False)

    args = parser.parse_args()

    overwrite = args.overwrite
    target = args.target


if __name__ == '__main__':
    parse_args()

    files = glob.glob(f'./methods/{target}/*')

    for file in files:
        generate(file)
